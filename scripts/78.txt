/***************************************************
Title:		Neoball
Author:	Mark Hoskins

Feel free to use, redistribute, steal, take credit for, or in any
other way utilize or mistreat the contents of this script.

***************************************************/

#include"dir.h"
#include<stdarg.h>

#define SOCCER_MAP_START 14
#define SOCCER_MAP_END   14

void soccerchat(char *chat, ...)
{
	char text[1024];
	va_list ap;
	va_start(ap,chat);
	vsprintf(text,chat,ap);
	va_end(ap);
	for(int i=SOCCER_MAP_START;i<=SOCCER_MAP_END;i++)
	{
		sendMapChatf(i,text);
	}
}

void nextmap(int &mapid,int &x,int &y,int socdir)
{
	cMap *map=mapStruct(mapid);
	if(!inBounds(x,y))
	{
		if(socdir==DIR_RIGHT)
		{
			mapid=map->e;
			x=0;
		}
		else if(socdir==DIR_LEFT)
		{
			mapid=map->w;
			x=19;
		}
		else if(socdir==DIR_UP)
		{
			mapid=map->n;
			y=14;
		}
		else
		{
			mapid=map->s;
			y=0;
		}
	}
}

struct Ball
{
	int mapid,omapid;
	int x,ox;
	int y,oy;
	int rmap;
	int rx;
	int ry;
	int owner;
	int oowner;
	int dir;
	int speed;
};

Ball balls[]=
{
	{14,14,9,9,7,7,14,9,7,-1,-1,0,0}
};

int numballs=sizeof(balls)/sizeof(Ball);

void save(Ball ball)
{
	ball.omapid=ball.mapid;
	ball.ox=ball.x;
	ball.oy=ball.y;
}

bool changed(Ball ball)
{
	return ball.omapid!=ball.mapid || ball.ox!=ball.x || ball.oy!=ball.y;
}

bool validpos(Ball ball)
{
	cMap *map=mapStruct(ball.mapid);
	if(inBounds(ball.x,ball.y))
	{
		return (pass(map->map[ball.y][ball.x].type) && getID(ball.mapid,ball.x,ball.y)==-1 && map->map[ball.y][ball.x].tile[3]==0)||(map->map[ball.y][ball.x].tile[3]==132);
	}
	soccerchat("-1: (%d) (%d)",ball.x,ball.y);
	return false;
}

Ball move(Ball ball)
{
	int mapid,x,y;
	if(ball.owner>-1)
	{
		cPlayer *player=playerStruct(ball.owner);
		mapid=player->map;
		x=player->x;
		y=player->y;
		dirapply(x,y,player->dir);
		nextmap(mapid,x,y,player->dir);
	}
	else if(ball.speed>0)
	{
		x = ball.x;
		y = ball.y;
		mapid = ball.mapid;
		dirapply(x,y,ball.dir);
		nextmap(mapid,x,y,ball.dir);
		ball.speed--;
		soccerchat("kicked (%d) (%d)",ball.speed,ball.dir);
	}
	ball.mapid=mapid;
	ball.x=x;
	ball.y=y;
	return ball;
}

int getowner(int ballid)
{
	Ball ball=balls[ballid];
	int lowest=-1;
	int lowid=-1;
	for(int i=0;i<4;i++)
	{
		int x=ball.x;
		int y=ball.y;
		dirapply(x,y,i);
		if(inBounds(x,y))
		{
			int victim=getID(ball.mapid,x,y);
			if(victim>-1)
			{
				cPlayer *player=playerStruct(victim);
				if(player->dir == opposite(i))
				{
					// Player is facing the ball.
					
					if(lowest==-1 || lowest>player->stationary)
					{
						// The ball is selected based on which nearby player has been stationary the shortest time.
						// The lowest either has not yet been selected or the new lowest has been found.
						lowid=victim;
						lowest=player->stationary;
					}	
				}
			}
		}
	}
	return lowid;
}

void moveball(Ball ball)
{
	cMap *map=mapStruct(ball.mapid);
	cMap *omap=mapStruct(ball.omapid);
	for(int x=0;x<20;x++)
	{
		for(int y=0;y<15;y++)
		{
			if(omap->map[y][x].tile[3]==132)
			{
				omap->map[y][x].tile[3]=0;
				omap->map[y][x].type=TILE_TYPE_NONE;
			}
		}
	}
	map->map[ball.y][ball.x].type=TILE_TYPE_WALL;
	map->map[ball.y][ball.x].tile[3]=132;
}

void main()
{
	for(int i=0;i<numballs;i++)
	{
		Ball ball;
		if(balls[i].speed<=0)
		{
			int owner=getowner(i);
			
			if(owner == -1)
			{
				owner = balls[i].owner;
			}
			
			if(owner > -1)
			{
				cPlayer *player = playerStruct(owner);
				soccerchat("owner %s (%d) (%d)",player->name,player->dir,balls[i].dir);
				if(player->stationary==0)
				{
					if(player->dir==balls[i].dir)
					{
						balls[i].speed=5;
						balls[i].owner=-1;
						balls[i].dir=player->dir;
						balls[i].mapid=player->map;
					}
					else
					{
						balls[i].speed=0;
						balls[i].owner=owner;
						balls[i].dir=player->dir;
						balls[i].mapid=player->map;
					}
					player->stationary=1;
					playerSave(owner);
				}
			}
		}
		if(balls[i].speed>0)
		{
			soccerchat("1: (%d)",balls[i].speed);
		}
		ball=balls[i];
		save(ball);
		ball=move(ball);
		soccerchat("0: (%d) (%d)",ball.x,ball.y);
		if(ball.speed>0)
		{
			soccerchat("2: (%d) (%d) (%d) (%d)",ball.speed,ball.x,balls[i].y,ball.mapid);
		}
		if(validpos(ball))
		{
			if(balls[i].speed>0)
			{
				soccerchat("3: (%d)",balls[i].speed);
			}
			balls[i]=ball;
			if(changed(ball))
			{
				soccerchat("oi");
				moveball(balls[i]);
				if(ball.mapid!=ball.omapid)
				{
					mapSave(ball.omapid);
					sendMapUpdate(ball.omapid);
				}
				mapSave(ball.mapid);
				sendMapUpdate(ball.mapid);
			}
			if(balls[i].speed>0)
			{
				soccerchat("4: (%d)",balls[i].speed);
			}
		}
		else
		{
			if(balls[i].speed>0)
			{
				soccerchat("5: (%d)",balls[i].speed);
			}
			balls[i].owner=-1;
			balls[i].speed=0;
		}
	}
	//runScript(myScript(),500);
}


/*#include"dir.h"
#include<stdarg.h>

#define BALL_TILE 132
#define KICK_LEN  5

void debugChat(char *chat, ...)
{
	long id = getPlayer();
	char text[1024];
	va_list ap;
	va_start(ap,chat);
	vsprintf(text,chat,ap);
	va_end(ap);
	sendChatf(id,text);
}

voidsoccerchat(char *chat, ...)
{
	char text[1024];
	va_list ap;
	va_start(ap,chat);
	vsprintf(text,chat,ap);
	va_end(ap);
	for(long i=1464;i<1472;i++)
	{
		sendMapChatf(i,text);
	}
}
void nextMap(long &mapid,long &x,long &y,long socdir)
{
	cMap *map=mapStruct(mapid);
	if(!inBounds(x,y))
	{
		if(socdir==DIR_RIGHT)
		{
			mapid=map->e;
			x=0;
		}
		else if(socdir==DIR_LEFT)
		{
			mapid=map->w;
			x=19;
		}
		else if(socdir==DIR_UP)
		{
			mapid=map->n;
			y=14;
		}
		else
		{
			mapid=map->s;
			y=0;
		}
	}
}

bool kick(long &owner, long mapid, short x, short y, short dir)
{
	long tempx;
	long tempy;
	long victim;
	cMap *map = mapStruct(mapid);
	
	map->map[y][x].tile[1] = 0;
	map->map[y][x].type    = TILE_TYPE_NONE;
	tempx = x;
	tempy = y;
	dirapply((long&)tempx,(long&)tempy,dir);
	
	for(short i = 0; i < KICK_LEN; i++)
	{
		if(inBounds(tempx,tempy) && map->map[tempy][tempx].type == TILE_TYPE_NONE)
		{
			x = tempx;
			y = tempy;
			victim = getID(mapid,x,y);
			if(victim == -1)
			{
				makeEffect(mapid,x,y,10);
				dirapply((long&)x,(long&)y,dir);
			}
			else
			{
				owner = victim;
				break;
			}
		}
		else
		{
			break;
		}
	}
	// debugChat("f");
	map->map[y][x].tile[1] = BALL_TILE;
	map->map[y][x].type    = TILE_TYPE_SWITCH;
	map->map[y][x].warp.map= myScript();
	
	
	
}

void main()
{
	long id = getPlayer();
	long stolen_by = -1;
	long old_ball_mapid = -1;
	long ball_mapid     = -1;
	cPlayer *player = playerStruct(id);
	cMap *map = mapStruct(player->id);
	cMap *ball_map;
	short ballx = player->x;
	short bally = player->y;
	short oldx,oldy;
	short tempx,tempy;
	char neoball_init[]   = "NEOBALL_INIT";
	char neoball_value[256];
	char owner_global[256];
	bool ball_mapid_changed = false;
	long debugnum = 0;
	
	sprintf(owner_global,"ballowner(%d)",id);
	dirapply(ballx,bally,player->dir);
	ball_mapid = player->map;
	// debugChat("a");
	// This script hasn't run yet since the last server crash, meaning the ball has no idea where it is.
	// So we'll initialize it so the ball knows where it is.
	if(!isGlobal(neoball_init))
	{
		// debugChat("b");
		oldx = ballx;
		oldy = bally;
		old_ball_mapid = player->map;
		ball_mapid     = player->map;
		sprintf(neoball_value, "(%d),(%d),(%d)", player->map, ballx, bally);
		setGlobalStr(neoball_init, neoball_value);
		setGlobalInt(owner_global,1);
	}
	// The game has been initialized but the person executing it has not been recognized as an owner.
	// Therefore, don't run the rest of the script.
	else if(!isGlobal(owner_global))
	{
		// debugChat("c");
		return;
	}
	// This guy is the owner, fetch the position of the ball.
	else
	{
		sscanf(globalStr(neoball_init), "(%d),(%d),(%d)", &old_ball_mapid, &oldx, &oldy);
		// debugChat("d");
	}
	
	if(player->stationary == 0)
	{
		// debugChat("e");
		if(oldy == bally && oldx == ballx)
		{
			
			ball_mapid_changed = true;
		}
		else
		{
			// debugChat("g (%d) (%d) (%d) (%d)", ballx, bally, oldx, oldy);
			
			if(inBounds(ballx,bally))
			{
				map->map[oldy][oldx].tile[1]    = 0;
				map->map[oldy][oldx].type       = TILE_TYPE_NONE;
				map->map[bally][ballx].tile[1]  = BALL_TILE;
				map->map[bally][ballx].type     = TILE_TYPE_SWITCH;
				map->map[bally][ballx].warp.map = myScript(); 
				ball_mapid_changed = true;
			}
			// debugChat("h");
		}
		player->stationary = 1;
		playerSave(id);
	}
	
	if(ball_mapid_changed)
	{
		// debugChat("i");
		mapSave(ball_mapid);
		sendMapUpdate(ball_mapid);
		sprintf(neoball_value, "(%d),(%d),(%d)", ball_mapid, ballx, bally);
		setGlobalStr(neoball_init,neoball_value);
		if(player->map != ball_mapid)
		{
			mapSave(player->map);
			sendMapUpdate(player->map);
		}
		
	}
	
	if(stolen_by == -1)
	{
		// debugChat("j");
		runScript(myScript(), 50);
	}
	else if(stolen_by > 0)
	{
		// debugChat("k");
		freeGlobal(owner_global);
		sprintf(owner_global,"ballowner(%d)",stolen_by);
		setGlobalInt(owner_global,1);
		runScriptAs(stolen_by, myScript(), 50);
	}
}*/